---
title: Basic Concepts for Genealogical Standards
date: 19 October 2017
numbersections: true
...
# Basic Concepts for Genealogical Standards

{.ednote ...} This is an **exploratory draft** of a standard covering 
basic concepts that are expected to be used in multiple FHISO standards.
This document is not endorsed by the FHISO membership, and may be
updated, replaced or obsoleted by other documents at any time. 
{/}

FHISO's **Basic Concepts for Genealogical Standards** standard defines
various low-level concepts that will be used in many FHISO standards,
and whose definitions do not logically belong in any one particular
higher-level standard.

The definition of a *string* which is used in multiple FHISO standards
is given in §2 of this standard, together with various related concepts
such as *characters* and *whitespace*.  *Terms* are defined in §3 as a
form of extensible identifier using IRIs; a shorthand notation for
*terms* known as *prefix notation* is described in §3.1, and a §3.2
discusses information that may be be retrieved from these IRI.

{.ednote} It is anticipated that a future draft will add definitions for
*datatypes* and *language tags*.

## Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *may* issue a warning or error message, and *may*
terminate processing of the document or data fragment.

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner.

## Characters and strings

{.ednote}  The concepts related to *strings* were originally defined in
the [CEV Concepts](https://tech.fhiso.org/TR/cev-concepts) draft.  This
section has been moved here to be more generally usable.

**Characters** are specified by reference to their **code point** number
in [ISO 10646], without regard to any particular character encoding.  In
this standard, *characters* may be identified in this standard by their
hexadecimal *code point* prefixed with "U+".

{.note} The character encoding is a property of the serialisation, and
not defined in this standard.  Non-Unicode encodings are not precluded,
so long as it is defined how characters in that encoding corresponds to
Unicode characters.

*Characters* *must* match the `Char` production from
&#x5B;[XML](https://www.w3.org/TR/xml11/)].

    Char  ::=  [#1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

{.note} This includes all *code points* except the null character,
surrogates (which are reserved for encodings such as UTF-16 and not
characters in their own right), and the invalid characters U+FFFE and
U+FFFF.

A **string** is a sequence of zero or more *characters*, and *should*
only be used to encode textual data.

{.note ...} This definition of a *string* is identical to the definition
of the `string` datatype defined in 
&#x5B;[XSD Pt2](https://www.w3.org/TR/xmlschema11-2/)], used in many XML
and Semantic Web technologies.

This definition of a *string* differs very slightly from JSON's
definition of a string, as defined in 
&#x5B;[RFC 7159](https://tools.ietf.org/html/rfc7159)], as a JSON string
may include the null *character* (U+0000).  This is the only difference
between a JSON string and FHISO's definition of a *string*.  As a
*string* *should not* be used to contain raw binary data, this
difference is not anticipated to cause a problem.  If an application
needs to store binary data in *string*, it *should* encode it in a
textual form, for example with the Base64 data encoding scheme defined in 
&#x5B;[RFC 4648](https://tools.ietf.org/html/rfc4648)].
{/}

Applications *may* convert any *string* into Unicode Normalization Form
C, as defined in any version of Unicode Standard Annex #15 &#x5B;[UAX
15](http://unicode.org/reports/tr15/)].

{.note} Normalization Form C and Normalization Form D allow easier
searching, sorting and comparison of *strings* by picking a canonical
representation of accented characters.  The conversion between
Normalization Forms C and D is lossless and therefore reversible, but
the initial conversion to either form is not reversible.  This allows a 
*conformant* application to normalise *strings* internally and not
retain the unnormalised form; however, an application doing so *must*
ensure the *string* is in Normalization Form C upon export, this being
the more usual form for use in documents.

*Characters* matching the `RestrictedChar` production from
&#x5B;[XML](https://www.w3.org/TR/xml11/)] *should not* appear in
*strings*, and applications *may* process such characters in an
implementation-defined manner or reject *strings* containing them.

    RestrictedChar  ::=  [#x1-#x8] | [#xB-#xC] | [#xE-#x1F]
                           | [#x7F-#x84] | [#x86-#x9F]

{.note} This includes all C0 and C1 control characters except tab
(U+0009), line feed (U+000A), carriage return (U+000D) and next line
(U+0085).

{.example} As *conformant* applications can process C1 control
characters in an implementation-defined manner, they can opt to handle
Windows-1252 quotation marks in data masquerading as Unicode.
Applications *must not* treat non-ASCII characters (other than C1
control characters) as ANSEL, the character set properly used in [GEDCOM],
as [ANSEL]'s non-ASCII characters do not correspond to `RestrictedChar`s.

*Conformant* applications *must* be able to store and process *strings*
containing arbitrary *characters* other than those matching the
`RestrictedChar`.  In particular, applications *must* be able to handle
*characters* which correspond to unassigned Unicode *code points* as
they may be assigned in future versions of [ISO 10646].  Applications
*must* also be able to handle *characters* outside Unicode's Basic
Multilingual Plane &mdash; that is, *characters* with a *code point*
of U+10000 or higher.

{.note} This means applications *must not* represent *strings*
internally in the UCS-2 encoding which does not accommodate *characters*
outside the Basic Multilingual Plane.  The UTF-16 encoding defined in
§2.6 of [ISO 10646] provides a 16-bit encoding that is backwards
compatible with UCS-2 but allows arbitrary *characters* to be
represented through the use of Unicode surrogate pairs.

**Whitespace** is defined as a sequence of one or more space
*characters*, carriage returns, line feeds, or tabs.  It matches the
production `S` from &#x5B;[XML](https://www.w3.org/TR/xml11/)].

    S  ::=  (#x20 | #x9 | #xD | #xA)+

{.note}  This definition only includes common ASCII whitespace
*characters* and does not include every *character* in [ISO 10646] that
could be considered to be a whitespace.  For example, the vertical tab
(U+000B), no-break space (U+00A0) and em space (U+2003) are all
excluded.

**Whitespace normalisation** is the process of discarding any leading
or trailing *whitespace*, and replacing other *whitespace* with a single
space (U+0020) *character*.  

{.note}  The definition of *whitespace normalisation* is identical to
that in &#x5B;[XML](https://www.w3.org/TR/xml11/)].

In the event of a difference between the definitions of the `Char`,
`RestrictedChar` and `S` productions given here and those in
&#x5B;[XML](https://www.w3.org/TR/xml11/)], the definitions in the
latest edition of XML 1.1 specification are definitive.

## Terms

{.ednote}  The concept of a *term* was originally defined in the 
[CEV Concepts](https://tech.fhiso.org/TR/cev-concepts) draft.  It has
been moved here to be more generally usable.  The material in §3.3 and
§3.4 is new in this draft of Basic Concepts, but draws heavily on FHISO's
[Vocabularies policy](https://tech.fhiso.org/policies/vocabularies).

A **term** is a form of identifier used in FHISO standards to represent
a concepts which it is useful to be able to reference.  A *term*
consists of a unique, machine-readable identifier, known as the **term
name**, paired with a clearly-defined meaning for the concept or idea
that it represents.  *Term names* *shall* take the form of an IRI
matching the `IRI` production in §2.2 of
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)]. 

{.ednote ...} Add an example of what a term name is used for.  Once
*datatypes* are moved here, we can add the following sentence to the
previous paragraph

> This standard uses *terms* as *datatypes*, as defined in §X of this
> standard.
{/}

{.note} IRIs have been chosen in preference to URIs because it is
recognised that certain culture-specific genealogical concepts may not
have English names, and in such cases the human-legibility of IRIs is
advantageous.  URIs are a subset of IRIs, and all the *terms* defined in
this suite of standard are also URIs.

*Term names* are compared using the "simple string comparison" algorithm
given in §5.3.1 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)].  If a *term
name* does not compare equal to an IRI known to the application,
the application *must not* make any assumptions about the
*term*, its meaning or intended use, based on the form of the IRI or any
similarity to other IRIs.

{.note} This comparison is a simple character-by-character comparison,
with no normalisation carried out on the IRIs prior to comparison.  It
is also how XML namespace names are compared in 
&#x5B;[XML Names](https://www.w3.org/TR/xml-names11/)].

{.example ...}  The following IRIs are all distinct for the purpose of
the "simple string comparison" algorithm given in §5.3.1 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)], , even though an
HTTP request to them would fetch the same resource.

    https://éléments.example.com/nationalité
    HTTPS://ÉLÉMENTS.EXAMPLE.COM/nationalit%C3%A9
    https://xn--lments-9uab.example.com/nationalit%c3%a9

{/}

An IRI *must not* be used as a *term name* unless it can be converted to
a URI using the algorithm specified in §3.1 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)], and back to a IRI
again using the algorithm specified in §3.2 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)], to yield the
original IRI.

{.note}  This requirement ensures that *term names* can be used in a
context where a URI is required, and that the original IRI can be
regenerated, for example for comparison with a list of known IRIs.  The
vast majority of IRIs, including those in non-Latin scripts, have this
property.  The effect of this requirement is to prohibit the use of IRIs
that are already partly converted to a URI, for example through the use
of unnecessary percent or punycode encoding.

{.example}  Of the three IRIs given in the previous example on how to
compare IRIs, only the first may be used as a *term name*.  The second
and third are prohibited as a result of the unnecessary
percent-encoding, and the third is additionally prohibited as a result
of unnecessary punycode-encoding.

The *terms* defined in FHISO standards all have *term names* that begin
`https://terms.fhiso.org/`.  Subject to the requirements in the
applicable standards, third parties may also define additional *terms*.
It is *recommended* that any such *terms* use either the `http` or
preferably the `https` IRI scheme defined in §2.7.1 and §2.7.2 of
&#x5B;[RFC 7230](https://tools.ietf.org/html/rfc7230)] respectively, and
an authority component consisting of just a domain name or subdomain
under the control of the party defining the *term*.

{.note ...} An `http` or `https` IRI scheme is *recommended* because the
IRI is used to fetch a resource during *discovery*, and it is desirable
that applications implementing *discovery* should only need to support a
minimal number of transport protocols.  URN schemes like the `uuid`
scheme of &#x5B;[RFC 4122](https://tools.ietf.org/html/rfc4122)] are
*not recommended* as they do not have transport protocols that can be
used during *discovery*.

The preference for a `https` IRI is because of security considerations
during *discovery*.  A man-in-the-middle attack during *discovery* could
insert malicious content into the response, which, if undetected, could
cause an application to process user data incorrectly, potentially
discarding parts of it or otherwise compromising its integrity.  It is
harder to stage a man-in-the-middle attack over TLS, especially if
public key pinning is used per 
&#x5B;[RFC 7469](https://tools.ietf.org/html/rfc7469)].
{/}

### Prefix notation

*Term names* are sometimes referred using **prefix notation**.  This is
a system whereby **prefixes** are assigned to IRIs that occur frequently
as the leading portion of a *term name*.  Then, instead of writing the
*term name* in full, the leading portion of the *term name* is replaced
by its *prefix* followed by a colon (U+003A) separator.

{.example}  The *term name* `https://terms.fhiso.org/sources/title` is
used in several of the examples in this standard.  Instead of writing
this in full, if the `cev` *prefix* is bound to the IRI
`https://terms.fhiso.org/sources/`, then this IRI can be written in
*prefix form* as `cev:title`.

The following *prefix* bindings are assumed in this standard:
 
------           -----------------------------------------------
`rdf`            `http://www.w3.org/1999/02/22-rdf-syntax-ns#`
`rdfs`           `http://www.w3.org/2000/01/rdf-schema#`
------           -----------------------------------------------

{.note}  The particular *prefix* assigned above have no relevance
outside this standard document as *prefix notation* is not used in the
formal data model defined by this standard.  This notation is simply a
notational convenience to make the standard easier to read.

{.ednote} If *prefix notation* is used outside this section of the
standard, the bindings above should be moved to §1.

### IRI resolution
 
It is *recommended* that an HTTP `GET` request to a *term name* IRI with
an `http` or `https` scheme (once converted to a URI per §4.1 of
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)]), *should* result
in a 303 "See Other" redirect to a document containing a human-readable
definition of the *term* if the request was made without an `Accept`
header or with an `Accept` header matching the format of the
human-readable definition.  It is further *recommended* that this
format should be HTML, and that documentation in alternative formats
*may* be made available via HTTP content negotiation when the request
includes a suitable `Accept` header, per §5.3.2 of 
&#x5B;[RFC 7231](//tools.ietf.org/html/rfc7231)].

{.note}  A 303 redirect is considered best practice for &#x5B;[Linked
Data](http://linkeddatabook.com/editions/1.0/)], so as to avoid
confusing the *term name* IRI with the document containing its
definition, which is found at the post-redirect URL.  The *terms*
defined in this suite of standards are not specifically designed for
use in Linked Data, but the same considerations apply.

Parties defining *terms* *may* arrange for their *term name* to
support **discovery**.  This when an HTTP `GET` request to a *term name*
IRI with an `http` or `https` scheme, made with an appropriate `Accept`
header, yields 303 redirect to a machine-readable definition of the 
*term*. 

{.ednote}  FHISO does not currently define a *discovery* mechanism, but
anticipate doing so in a future standard.  If such a standard is
included in the initial suite of standards, it is likely to be
*recommended* that parties defining *terms* *should* arrange for them to
support *discovery*, while application support for it would be
*optional*.

### Classes

{.note}  This section defines a basic type system for *terms*.  It is
provided primarily for use in *discovery*, support for which is
*optional*.

*Terms* are used in many contexts in FHISO standards and it can be
useful to have a concise, machine-readable way of stating the use for
which it was defined.  

A **class** is a *term* used to denote a particular context or use for
which other *terms* may be defined.  Standards defining such contexts
*should* define a *class* to represent that context, and *must* do so if
the third parties are permitted to define their own *terms* for use in
that context.

{.example ...}  A hypothetical standard might defined various *terms*
representing events of genealogical interest that might occur during a
person's lifetime.  Examples might include:

    https://example.com/events/Baptism  
    https://example.com/events/Ordination
    https://example.com/events/Emigration
    https://example.com/events/Death

The standard *should* provide a *class* to represent the abstract
concept of an event type, and as the *class* is itself a *term*, it must
have an IRI as its *term name*.  Perhaps it might be:

    https://example.com/events/EventType

This *class* might be referred to as the *class* of event types.
{/}

{.note} The words "class" and "type" are used in many contexts in
computing.  As used here, a *class* is similar to a datatype of which
*terms* are values, or a class of which *terms* are instances, or a
named enumeration type of which *terms* are values.  FHISO's use of this
word does not mean that the other notions associated with the word
"class" in object-oriented programming apply here.

The *term name* of a *class* is also referred to as its **class name**.

When a *term* has been defined for use in the context denoted by some
*class*, that *class* is referred to as the **type** of the *term*.  

{.example}  In *prefix notation*, with the *prefix* `ex` bound to
`https://example.com/events/`, the *type* of `ex:Baptism` from the
previous example is `ex:EventType`.

As a *class* is a *term*, defining a *class* is itself a context in
which *terms* are defined, including by third parties.  This means the
general concept of a *class* needs a *term* defining to represent it.
This standard uses the `rdfs:Class` *term* for this purpose:

    http://www.w3.org/2000/01/rdf-schema#Class

{.note}  This can be thought of as a *class* of *classes*.  It is not
merely an arcane abstraction: it serves a useful role in *discovery*.
If *discovery* is carried out on the *term name* of a *class*, it is
useful to be able to indicate that the *term* is a *class*.  This can be
done by saying the *type* of the *term* is `rdfs:Class`.

{.note ...}  Although the `rdfs:Class` *class* is defined in §2.2 of [RDF
Schema], this standard does not require support for any of the
facilities in [RDF Schema], nor are parties defining *classes* or
*terms* required to do so in a manner compatible with RDF.  An
implementer may safely use the `rdfs:Class` *class* for the purposes of
this standard using just the information given in this section without
reading [RDF Schema] or otherwise being familiar with RDF.  

The decision to use `rdfs:Class` and other *terms* from [RDF Schema] is
due to FHISO's practice of reusing facilities from existing standards when
they are a good match for our requirements, rather than inventing our
own versions with similar functionality.  It also allows future
standards and vendor extensions the option of reusing existing
third-party vocabularies where appropriate, as most such vocabularies
are also aligned with RDF.
{/}

The *type* of any *class* is therefore `rdfs:Class`.

{.note}  There is no need for a further level of abstraction to
represent the *type* of `rdfs:Class`.  As `rdfs:Class` is just another
*class*, albeit a fairly special one, the *type* of `rdfs:Class` is
`rdfs:Class`.

### Properties

{.note}  This section defines a simple vocabulary for describing *terms*.
It is provided primarily for use in *discovery*, support for which is
*optional*.

During *discovery*, and in other situations when a formal definition of a
particular *term* is needed, it is useful to have a formalism for
providing information on the *term*.  

A **property** is a *term* used to denote a particular piece of
information that might be provided when defining another *term*.
Standards which introduce such pieces of information *should* define a
*property* to represent them, and *must* do so if third parties are
permitted to define their own *terms* and if it is *recommended* or
*required* that these third parties document or otherwise make available
the information represented by the *property*.

{.example ...} An earlier example introduced several hypothetical
*terms* for events of genealogical interest, such as birth, baptism,
ordination, emigration and death.  Many events can occur multiple times
during a person's life: for example, a person might emigrate more than
once.  But other events cannot by definition occur more than once:
birth and death are obvious examples.  The number of times something is
permitted to occur is sometimes called its cardinality, and if the
authors of this hypothetical standard considered it a relevant concept,
they *should* define a *term* to represent the concept of cardinality:

    https://example.com/events/cardinality

If the hypothetical standard allows third parties to define additional
types of event, and either recommends or requires that they state the
cardinality of the new events, then the standard *must* define a *term
property* representing cardinality.
{/}

The *term name* of a *property* is also referred to as its *property
name*.

The *type* of a *term*, as introduced in §3.3, is a piece of information
which *should* normally be provided, albeit often implicitly, when
defining a *term*.  As such it needs a *property* to represent it.
This standard uses the `rdf:type` *term* for this purpose:

    http://www.w3.org/1999/02/22-rdf-syntax-ns#type

The *class* of *properties* has the following *class name*:

    http://www.w3.org/1999/02/22-rdf-syntax-ns#Property

{.note}  The `rdf:type` *property* and `rdf:Property` *class* are
defined §3.3 and §2.8 of [RDF Schema], respectively.  The fact that
their *term name* IRIs begin differently to the `rdfs:Class` *term name*
used in §3.3 of this standard is due to historical reasons.  As with the
`rdfs:Class` *term*, an implementer may safely use the `rdf:type` and
`rdf:Property` *terms* for the purposes of this standard without reading
[RDF Schema].

{.ednote}  We may need to introduce the concepts of the **range** and
**domain** of a *property*, currently in our 
[Vocabularies policy](https://tech.fhiso.org/policies/vocabularies).
However the *range* needs concepts associated with *datatypes*, which
are currently still in the 
[CEV Concepts](https://tech.fhiso.org/TR/cev-concepts) draft.
Careful consideration will be needed before the *domain* is introduced
to ensure it does not cause forwards compatibility problems if new uses
are found for the *property*.

## References

### Normative references

[ISO 10646]
:   ISO (International Organization for Standardization).  *ISO/IEC
    10646:2014. Information technology &mdash; Universal Coded Character
    Set (UCS).*  2014.

[RFC 2119]
:   IETF (Internet Engineering Task Force).  *RFC 2119:  Key words for
    use in RFCs to Indicate Requirement Levels.*  Scott Bradner, eds., 1997.
    (See <https://tools.ietf.org/html/rfc2119>.)

[RFC 3987]
:   IETF (Internet Engineering Task Force).  *RFC 3987:
    Internationalized Resource Identifiers (IRIs).*  Martin Duerst and
    Michel Suignard, eds., 2005. (See <https://tools.ietf.org/html/rfc3987>.)

[RFC 7230]
:   IETF (Internet Engineering Task Force).  *RFC 7230:  Hypertext
    Transfer Protocol (HTTP/1.1): Message Syntax and Routing.*  Roy
    Fieldind and Julian Reschke, eds., 2014.  (See
    <https://tools.ietf.org/html/rfc7230>.)

[RFC 7231]
:   IETF (Internet Engineering Task Force).  *RFC 7231:  Hypertext
    Transfer Protocol (HTTP/1.1): Semantics and Content.*  Roy
    Fieldind and Julian Reschke, eds., 2014.  (See
    <https://tools.ietf.org/html/rfc7231>.)

[UAX 15]
:   The Unicode Consortium.  "Unicode Standard Annex 15: Unicode
    Normalization Forms" in *The Unicode Standard, Version 8.0.0.*
    Mark Davis and Ken Whistler, eds., 2015.  (See
    <http://unicode.org/reports/tr15/>.)

[XML]
:   W3C (World Wide Web Consortium). *Extensible Markup Language (XML) 1.1*, 
    2nd edition.  Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve
    Maler, François Yergeau, and John Cowan eds., 2006.  W3C
    Recommendation.  (See <https://www.w3.org/TR/xml11/>.)

### Other references

[ANSEL]
:   NISO (National Information Standards Organization).
    *ANSI/NISO Z39.47-1993.
    Extended Latin Alphabet Coded Character Set for Bibliographic Use*.
    1993.  (See 
    <http://www.niso.org/apps/group_public/project/details.php?project_id=10>.)
    Standard withdrawn, 2013.

[GEDCOM]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, draft release 5.5.1.  2 Oct 1999.

[RDF Schema]
:   W3C (World Wide Web Consortium). *RDF Schema 1.1*.
    Dan Brickley and R.&nbsp;V. Guha, eds., 2014.
    W3C Recommendation.  (See <https://www.w3.org/TR/rdf-schema>.)

[RFC 4648]
:   IETF (Internet Engineering Task Force).  *RFC 4648:  The Base16,
    Base32, and Base64 Data Encodings*.   S. Josefsson, ed., 2006.
    (See <https://tools.ietf.org/html/rfc4648>.)

[RFC 7159]
:   IETF (Internet Engineering Task Force).  *RFC 7159:  The JavaScript
    Object Notation (JSON) Data Interchange Format*.  T. Bray, ed., 2014.
    (See <https://tools.ietf.org/html/rfc7159>.)

[RFC 7469]
:   IETF (Internet Engineering Task Force).  *Public Key Pinning
    Extension for HTTP*.  C. Evans, C. Palmer and R. Sleevi, ed., 2015.
    (See <https://tools.ietf.org/html/rfc7469>.)


[XML Names]
:   W3 (World Wide Web Consortium). *Namespaces in XML 1.1*, 2nd edition.
    Tim Bray, Dave Hollander, Andrew Layman and Richard Tobin, ed., 2006. 
    W3C Recommendation.  (See <https://www.w3.org/TR/xml-names11/>.)

[XSD Pt2]
:   W3 (World Wide Web Consortium). *W3C XML Schema Definition Language 
    (XSD) 1.1 Part 2: Datatypes*.  David Peterson, Shudi Gao (高殊镝),
    Ashok Malhotra, C. M. Sperberg-McQueen and Henry S. Thompson, ed., 2012.
    W3C Recommendation.  (See <https://www.w3.org/TR/xmlschema11-2/>.)


----
Copyright © 2017, [Family History Information Standards Organisation,
Inc](https://fhiso.org/).  
The text of this standard is available under the
[Creative Commons Attribution 4.0 International
License](https://creativecommons.org/licenses/by/4.0/).
